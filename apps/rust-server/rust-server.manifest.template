# SPDX-License-Identifier: AGPL-3.0-or-later
# Copyright (C) 2026 Relational Network

# =====================================================================
# LOCAL DEV Gramine manifest — used by `make` only.
# sgx.debug = true; encryption uses a persistent file-based key.
# For production (Docker), see docker/rust-server.manifest.template.
# =====================================================================

# Use gramine-ratls as the entrypoint to generate RA-TLS credentials before
# launching the actual application. The -P flag writes the private key
# unencrypted (required for rustls to load it).
libos.entrypoint = "{{ entrypoint }}"

loader.log_level = "{{ log_level }}"

loader.argv = [
    "gramine-ratls", "-P",
    "/tmp/ra-tls.crt.pem",
    "/tmp/ra-tls.key.pem",
    "--",
    "{{ self_exe }}"
]

loader.env.LD_LIBRARY_PATH = "/lib:{{ arch_libdir }}"
loader.env.HOST = "0.0.0.0"
loader.env.PORT = "8080"

# See https://gramine.readthedocs.io/en/stable/performance.html#glibc-malloc-tuning
loader.env.MALLOC_ARENA_MAX = "1"

# For easier debugging — not strictly required to run this workload
loader.env.RUST_BACKTRACE = "full"

# ========== AUTH & CORS (passthrough from host) ==========
# Source .env before running: `set -a; . ./.env; set +a`
# Or use `make start-rust-server` which auto-sources .env.
loader.env.CLERK_JWKS_URL  = { passthrough = true }
loader.env.CLERK_ISSUER    = { passthrough = true }
loader.env.CLERK_AUDIENCE  = { passthrough = true }
loader.env.CORS_ALLOWED_ORIGINS = { passthrough = true }

# ========== FIAT PROVIDER (TRUELAYER SANDBOX) ==========
# Required for live sandbox on-ramp/off-ramp flows.
loader.env.TRUELAYER_CLIENT_ID = { passthrough = true }
loader.env.TRUELAYER_CLIENT_SECRET = { passthrough = true }
loader.env.TRUELAYER_SIGNING_KEY_ID = { passthrough = true }
loader.env.TRUELAYER_SIGNING_PRIVATE_KEY_PEM = { passthrough = true }
loader.env.TRUELAYER_SIGNING_PRIVATE_KEY_PATH = { passthrough = true }
loader.env.TRUELAYER_MERCHANT_ACCOUNT_ID = { passthrough = true }
loader.env.TRUELAYER_OFFRAMP_ACCOUNT_HOLDER_NAME = { passthrough = true }
loader.env.TRUELAYER_OFFRAMP_IBAN = { passthrough = true }

# Optional provider endpoint/currency overrides.
loader.env.TRUELAYER_API_BASE_URL = { passthrough = true }
loader.env.TRUELAYER_AUTH_BASE_URL = { passthrough = true }
loader.env.TRUELAYER_HOSTED_PAYMENTS_BASE_URL = { passthrough = true }
loader.env.TRUELAYER_CURRENCY = { passthrough = true }

fs.mounts = [
    { path = "/lib", uri = "file:{{ gramine.runtimedir() }}" },
    { path = "{{ arch_libdir }}", uri = "file:{{ arch_libdir }}" },
    { path = "{{ app_dir }}", uri = "file:{{ app_dir }}" },
    # tmpfs mount for RA-TLS certificate and key generation
    { path = "/tmp", type = "tmpfs" },
    # gramine-ratls binary location (passed via -Dentrypoint)
    { path = "{{ entrypoint }}", uri = "file:{{ entrypoint }}" },

    # ========== DNS RESOLUTION FOR NETWORK ACCESS ==========
    # Required for connecting to external RPC endpoints (Avalanche, etc.)
    { path = "/etc/resolv.conf", uri = "file:/etc/resolv.conf" },
    { path = "/etc/hosts", uri = "file:/etc/hosts" },
    { path = "/etc/nsswitch.conf", uri = "file:/etc/nsswitch.conf" },

    # ========== ENCRYPTED PERSISTENT STORAGE ==========
    # Persistent file-based key so /data survives enclave rebuilds during dev.
    # Production uses _sgx_mrsigner (see docker/rust-server.manifest.template).
    { path = "/data", uri = "file:{{ data_dir }}", type = "encrypted", key_name = "_dev_key" },
]

# Dev storage key — a static 16-byte hex secret read from data/.dev_storage_key.
# NOT derived from enclave identity, so data persists across rebuilds.
fs.insecure__keys._dev_key = "{{ dev_storage_key }}"

# SGX configuration - DCAP attestation is mandatory
sgx.debug = true
sgx.remote_attestation = "{{ ra_type }}"
sgx.isvprodid = {{ isvprodid }}
sgx.isvsvn = {{ isvsvn }}
sgx.edmm_enable = {{ 'true' if env.get('EDMM', '0') == '1' else 'false' }}

sgx.use_exinfo = {{ 'true' if env.get('EDMM', '0') == '1' else 'false' }}

sgx.trusted_files = [
    "file:{{ self_exe }}",
    "file:{{ gramine.runtimedir() }}/",
    "file:{{ arch_libdir }}/",
    "file:{{ entrypoint }}",
]

# Allow reading DNS configuration files (network access)
sgx.allowed_files = [
    "file:/etc/resolv.conf",
    "file:/etc/hosts",
    "file:/etc/nsswitch.conf",
]

# The maximum number of threads in a single process needs to be declared in advance.
sgx.max_threads = {{ '1' if env.get('EDMM', '0') == '1' else '8' }}
