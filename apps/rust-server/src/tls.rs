// SPDX-License-Identifier: AGPL-3.0-or-later
//
// Copyright (C) 2026 Relational Network

//! TLS utilities for loading RA-TLS certificates generated by Gramine.
//!
//! Gramine's `gramine-ratls` tool emits certificates with non-standard PEM labels:
//! - `-----BEGIN TRUSTED CERTIFICATE-----` instead of `-----BEGIN CERTIFICATE-----`
//!
//! This module normalizes such PEM files so that rustls can parse them correctly.

use rustls::pki_types::pem::PemObject;
use rustls::pki_types::{CertificateDer, PrivateKeyDer};
use std::fs;
use std::path::Path;

/// Default path where gramine-ratls writes the TLS certificate.
#[allow(dead_code)]
pub const RA_TLS_CERT_PATH: &str = "/tmp/ra-tls.crt.pem";

/// Default path where gramine-ratls writes the TLS private key.
#[allow(dead_code)]
pub const RA_TLS_KEY_PATH: &str = "/tmp/ra-tls.key.pem";

/// Errors that can occur when loading TLS credentials.
#[derive(Debug)]
#[allow(dead_code)]
pub enum TlsError {
    /// Certificate file not found or unreadable.
    CertificateNotFound(String),
    /// Private key file not found or unreadable.
    PrivateKeyNotFound(String),
    /// Failed to parse certificate.
    CertificateParseError(String),
    /// Failed to parse private key.
    PrivateKeyParseError(String),
    /// No certificates found in file.
    NoCertificatesFound,
    /// No private key found in file.
    NoPrivateKeyFound,
}

impl std::fmt::Display for TlsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TlsError::CertificateNotFound(path) => {
                write!(f, "TLS certificate not found at: {path}")
            }
            TlsError::PrivateKeyNotFound(path) => {
                write!(f, "TLS private key not found at: {path}")
            }
            TlsError::CertificateParseError(msg) => {
                write!(f, "Failed to parse TLS certificate: {msg}")
            }
            TlsError::PrivateKeyParseError(msg) => {
                write!(f, "Failed to parse TLS private key: {msg}")
            }
            TlsError::NoCertificatesFound => {
                write!(f, "No certificates found in certificate file")
            }
            TlsError::NoPrivateKeyFound => {
                write!(f, "No private key found in key file")
            }
        }
    }
}

impl std::error::Error for TlsError {}

/// Normalize RA-TLS PEM content by replacing non-standard labels.
///
/// Gramine's RA-TLS generates certificates with `TRUSTED CERTIFICATE` labels,
/// which rustls does not recognize. This function converts them to standard
/// `CERTIFICATE` labels.
fn normalize_ratls_pem(pem_content: &str) -> String {
    pem_content
        .replace("-----BEGIN TRUSTED CERTIFICATE-----", "-----BEGIN CERTIFICATE-----")
        .replace("-----END TRUSTED CERTIFICATE-----", "-----END CERTIFICATE-----")
}

/// Load and parse the RA-TLS certificate from the given path.
///
/// This function handles Gramine's non-standard PEM labels by normalizing them
/// before parsing. It returns a vector of certificates (typically one).
pub fn load_ratls_certificate<P: AsRef<Path>>(
    path: P,
) -> Result<Vec<CertificateDer<'static>>, TlsError> {
    let path = path.as_ref();

    // Read the raw PEM content
    let pem_content = fs::read_to_string(path)
        .map_err(|_| TlsError::CertificateNotFound(path.display().to_string()))?;

    // Normalize RA-TLS PEM labels
    let normalized = normalize_ratls_pem(&pem_content);

    // Parse certificates from normalized PEM using rustls built-in PEM support
    let certs: Vec<CertificateDer<'static>> =
        CertificateDer::pem_slice_iter(normalized.as_bytes())
            .collect::<Result<Vec<_>, _>>()
            .map_err(|e| TlsError::CertificateParseError(e.to_string()))?;

    if certs.is_empty() {
        // Try parsing as DER if PEM parsing yielded no certs
        let der_bytes = fs::read(path)
            .map_err(|_| TlsError::CertificateNotFound(path.display().to_string()))?;
        return Ok(vec![CertificateDer::from(der_bytes)]);
    }

    Ok(certs)
}

/// Load and parse the RA-TLS private key from the given path.
///
/// Supports PKCS#8, RSA, and EC private key formats.
pub fn load_ratls_private_key<P: AsRef<Path>>(
    path: P,
) -> Result<PrivateKeyDer<'static>, TlsError> {
    let path = path.as_ref();

    // Read the raw content
    let content = fs::read(path)
        .map_err(|_| TlsError::PrivateKeyNotFound(path.display().to_string()))?;

    // Parse private key using rustls built-in PEM support
    // PrivateKeyDer::from_pem_slice automatically tries PKCS#8, PKCS#1 (RSA), and SEC1 (EC) formats
    match PrivateKeyDer::from_pem_slice(&content) {
        Ok(key) => Ok(key),
        Err(_) => Err(TlsError::PrivateKeyParseError(
            "Could not parse private key in any supported format (PKCS#8, RSA, EC)".to_string(),
        )),
    }
}

/// Load both certificate and private key from the default RA-TLS paths.
///
/// This is a convenience function that loads from:
/// - Certificate: `/tmp/ra-tls.crt.pem`
/// - Private key: `/tmp/ra-tls.key.pem`
///
/// # Panics
///
/// Panics if either file is missing or cannot be parsed. This is intentional
/// as the server cannot operate securely without valid TLS credentials.
#[allow(dead_code)]
pub fn load_ratls_credentials() -> (Vec<CertificateDer<'static>>, PrivateKeyDer<'static>) {
    let certs = load_ratls_certificate(RA_TLS_CERT_PATH).unwrap_or_else(|e| {
        panic!(
            "Failed to load RA-TLS certificate from {}: {}",
            RA_TLS_CERT_PATH, e
        )
    });

    let key = load_ratls_private_key(RA_TLS_KEY_PATH).unwrap_or_else(|e| {
        panic!(
            "Failed to load RA-TLS private key from {}: {}",
            RA_TLS_KEY_PATH, e
        )
    });

    (certs, key)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_normalize_ratls_pem() {
        let input = "-----BEGIN TRUSTED CERTIFICATE-----\nMIIB...\n-----END TRUSTED CERTIFICATE-----";
        let expected = "-----BEGIN CERTIFICATE-----\nMIIB...\n-----END CERTIFICATE-----";
        assert_eq!(normalize_ratls_pem(input), expected);
    }

    #[test]
    fn test_normalize_standard_pem_unchanged() {
        let input = "-----BEGIN CERTIFICATE-----\nMIIB...\n-----END CERTIFICATE-----";
        assert_eq!(normalize_ratls_pem(input), input);
    }

    #[test]
    fn test_certificate_not_found_error() {
        let result = load_ratls_certificate("/nonexistent/path.pem");
        assert!(matches!(result, Err(TlsError::CertificateNotFound(_))));
    }

    #[test]
    fn test_private_key_not_found_error() {
        let result = load_ratls_private_key("/nonexistent/path.pem");
        assert!(matches!(result, Err(TlsError::PrivateKeyNotFound(_))));
    }
}
